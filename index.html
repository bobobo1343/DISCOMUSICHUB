<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DISCOMUSICHUB Advanced Player</title>
<style>
  /* Basic Reset and style */
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212; color: #eee; display: flex; height: 100vh; overflow: hidden;
  }
  #sidebar {
    width: 320px; background: #181818; overflow-y: auto; padding: 16px; border-right: 1px solid #333;
  }
  #content {
    flex: 1; display: flex; flex-direction: column;
  }
  header {
    background: #1db954; color: #121212; font-size: 24px; font-weight: 700;
    padding: 16px 24px; user-select: none;
  }
  #search-container {
    padding: 10px 20px; background: #282828;
  }
  #search {
    width: 100%; padding: 10px; border-radius: 6px; border: none; font-size: 16px; background: #121212; color: #eee;
  }
  #folder-tree {
    margin-top: 10px;
    list-style: none;
    padding-left: 0;
  }
  #folder-tree li {
    cursor: pointer;
    padding: 6px 8px;
    border-radius: 4px;
    user-select: none;
    position: relative;
  }
  #folder-tree li:hover {
    background: #1db954;
    color: #121212;
  }
  #folder-tree li.folder > .folder-name::before {
    content: "‚ñ∂"; display: inline-block; margin-right: 6px; transition: transform 0.2s ease;
  }
  #folder-tree li.folder.expanded > .folder-name::before {
    transform: rotate(90deg);
  }
  #folder-tree ul {
    padding-left: 16px;
    display: none;
  }
  #folder-tree li.folder.expanded > ul {
    display: block;
  }
  #folder-tree li.file {
    padding-left: 22px;
  }
  #folder-tree li.file:hover {
    background: #1ed760;
    color: #121212;
  }
  #player {
    background: #121212; padding: 20px 24px; display: flex; align-items: center; gap: 20px;
  }
  #player img {
    width: 96px; height: 96px; border-radius: 12px; object-fit: cover;
    box-shadow: 0 0 15px #1db954;
    flex-shrink: 0;
  }
  #player .info {
    flex-grow: 1;
    overflow: hidden;
  }
  #player .info .title {
    font-size: 20px; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  #player .info .artist {
    font-size: 14px; color: #b3b3b3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  #player .time {
    font-size: 12px; color: #999; margin-top: 4px;
  }
  #controls {
    display: flex; align-items: center; gap: 16px;
  }
  #controls button {
    background: none; border: none; color: #1db954;
    font-size: 28px; cursor: pointer; user-select: none;
    transition: transform 0.2s ease;
  }
  #controls button:active {
    transform: scale(0.9);
  }
  #progress-container {
    flex-grow: 1; height: 8px; background: #282828; border-radius: 4px; margin: 0 16px; cursor: pointer; position: relative;
  }
  #progress {
    height: 8px; background: #1db954; border-radius: 4px; width: 0%;
    transition: width 0.1s linear;
  }
  #queue {
    background: #181818; height: 300px; overflow-y: auto; padding: 16px;
    border-top: 1px solid #333;
  }
  #queue h2 {
    margin: 0 0 12px 0; font-weight: 600; color: #1db954;
  }
  #queue-list {
    list-style: none; padding: 0; margin: 0;
  }
  #queue-list li {
    padding: 8px 12px; margin-bottom: 6px; background: #282828; border-radius: 6px; cursor: pointer;
    display: flex; justify-content: space-between; align-items: center;
  }
  #queue-list li.playing {
    background: #1ed760;
    color: #121212;
    font-weight: 700;
  }
  #queue-list li .remove-btn {
    color: #e55353; cursor: pointer; font-weight: 700;
  }
  #volume-container {
    display: flex; align-items: center; gap: 8px;
  }
  #volume-slider {
    width: 100px;
  }
  #repeat-shuffle {
    display: flex; gap: 10px; margin-left: 16px;
  }
  #repeat, #shuffle {
    cursor: pointer; font-size: 20px; color: #1db954; user-select: none;
  }
  #repeat.active, #shuffle.active {
    color: #1ed760;
  }
  #theme-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    background: #1db954;
    color: #121212;
    border: none;
    border-radius: 20px;
    padding: 8px 12px;
    cursor: pointer;
    font-weight: 700;
  }
</style>
</head>
<body>

<button id="theme-toggle">Light Mode</button>

<div id="sidebar">
  <header>DISCOMUSICHUB</header>
  <div id="search-container">
    <input id="search" type="search" placeholder="Search folders & songs..." autocomplete="off" />
  </div>
  <ul id="folder-tree"></ul>
</div>

<div id="content">
  <div id="player">
    <img id="artwork" src="https://via.placeholder.com/96?text=No+Artwork" alt="Artwork" />
    <div class="info">
      <div class="title" id="song-title">No song playing</div>
      <div class="artist" id="song-artist"></div>
      <div class="time" id="time-info">0:00 / 0:00</div>
    </div>
    <div id="controls">
      <button id="prev" title="Previous">‚èÆÔ∏è</button>
      <button id="play-pause" title="Play/Pause">‚ñ∂Ô∏è</button>
      <button id="next" title="Next">‚è≠Ô∏è</button>
    </div>
    <div id="progress-container" title="Seek">
      <div id="progress"></div>
    </div>
    <div id="volume-container" title="Volume">
      <button id="mute-toggle" title="Mute/Unmute">üîä</button>
      <input type="range" id="volume-slider" min="0" max="1" step="0.01" />
    </div>
    <div id="repeat-shuffle">
      <div id="repeat" title="Repeat Off/One/All">üîÅ</div>
      <div id="shuffle" title="Shuffle On/Off">üîÄ</div>
    </div>
  </div>

  <div id="queue">
    <h2>Playlist Queue</h2>
    <ul id="queue-list"></ul>
  </div>
</div>

<script>
const API_KEY = 'AIzaSyCoNrL7Omej-ct3IlB02OjTMhvtVFmy0b0';

const ARTISTS = {
  'PLAYBOICARTI': '1tgOfvE-l9iBiXtzii8Xkx44U6mOwaItK',
  'KEN CARSON': '1B3jfYcb7ikY-YiqUWNIFqU9GJd22MeVN',
  'DESTROY LONELY': '1I0-pM0AbW2mSybBc6HVFuYMyFDQ2nasm'
};

const METADATA_JSONS = [
  'playboicarti.json',
  'ken_carson.json',
  'destroy_lonely.json'
];

const folderTree = document.getElementById('folder-tree');
const searchInput = document.getElementById('search');
const queueList = document.getElementById('queue-list');

const artworkImg = document.getElementById('artwork');
const songTitle = document.getElementById('song-title');
const songArtist = document.getElementById('song-artist');
const timeInfo = document.getElementById('time-info');

const playPauseBtn = document.getElementById('play-pause');
const prevBtn = document.getElementById('prev');
const nextBtn = document.getElementById('next');
const progressContainer = document.getElementById('progress-container');
const progress = document.getElementById('progress');
const volumeSlider = document.getElementById('volume-slider');
const muteToggle = document.getElementById('mute-toggle');
const repeatBtn = document.getElementById('repeat');
const shuffleBtn = document.getElementById('shuffle');
const themeToggleBtn = document.getElementById('theme-toggle');

let audio = new Audio();
let currentNode = null;
let metadataMap = {};
let rootNode = null;

let queue = [];
let currentIndex = -1;
let isPlaying = false;

let repeatMode = 0; // 0=off,1=one,2=all
let shuffleMode = false;

let folderCache = {}; // id => node object to prevent refetching

// Tree node structure
class TreeNode {
  constructor(id, name, isFolder, parent = null) {
    this.id = id;
    this.name = name;
    this.isFolder = isFolder;
    this.parent = parent;
    this.children = [];
    this.files = [];
  }
}

// Load metadata from GitHub JSONs
async function loadMetadata() {
  metadataMap = {};
  for (const jsonFile of METADATA_JSONS) {
    try {
      const url = `https://raw.githubusercontent.com/bobobo1343/DISCOMUSICHUB/main/${jsonFile}`;
      const res = await fetch(url);
      if (!res.ok) {
        console.warn(`Failed to load metadata JSON: ${jsonFile}`);
        continue;
      }
      const json = await res.json();
      json.forEach(item => {
        if(item.title) metadataMap[item.title] = item;
      });
    } catch (e) {
      console.warn('Error loading metadata JSON:', jsonFile, e);
    }
  }
}

// Google Drive API fetch folder contents with pagination
async function fetchFolderContents(folderId, pageToken = null) {
  let url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+trashed=false&key=${API_KEY}&fields=nextPageToken,files(id,name,mimeType,thumbnailLink)`;
  if (pageToken) url += `&pageToken=${pageToken}`;

  const res = await fetch(url);
  const data = await res.json();
  if (data.error) {
    alert('Google Drive API error: ' + data.error.message);
    return null;
  }
  return data;
}

// Recursively build full folder tree and files
async function buildTree(folderId, folderName, parent=null) {
  const node = new TreeNode(folderId, folderName, true, parent);
  folderCache[folderId] = node;

  let pageToken = null;
  do {
    const data = await fetchFolderContents(folderId, pageToken);
    if (!data) break;

    for (const file of data.files) {
      if (file.mimeType === 'application/vnd.google-apps.folder') {
        const childFolder = await buildTree(file.id, file.name, node);
        node.children.push(childFolder);
      } else if (file.mimeType.startsWith('audio/')) {
        node.files.push(file);
      }
    }
    pageToken = data.nextPageToken;
  } while(pageToken);

  return node;
}

// Render folder tree as nested UL
function renderFolderTree(node, parentUl) {
  const li = document.createElement('li');
  li.classList.add(node.isFolder ? 'folder' : 'file');

  if (node.isFolder) {
    const span = document.createElement('span');
    span.classList.add('folder-name');
    span.textContent = node.name;
    span.onclick = () => {
      li.classList.toggle('expanded');
      if (currentNode !== node) {
        currentNode = node;
        renderFiles(node);
      }
    };
    li.appendChild(span);

    const ul = document.createElement('ul');
    node.children.forEach(child => renderFolderTree(child, ul));
    // Files as leaf nodes:
    node.files.forEach(file => {
      const fileLi = document.createElement('li');
      fileLi.classList.add('file');
      fileLi.textContent = file.name;
      fileLi.title = file.name;
      fileLi.onclick = () => playFile(file, node);
      ul.appendChild(fileLi);
    });

    li.appendChild(ul);
  } else {
    li.textContent = node.name;
    li.onclick = () => playFile(node);
  }
  parentUl.appendChild(li);
}

// Render current folder files (for breadcrumb-style UI if needed)
function renderFiles(node) {
  // For now, highlight selected folder in sidebar and clear queue (optional)
  [...folderTree.querySelectorAll('li.folder span')].forEach(span => {
    if(span.textContent === node.name) {
      span.style.color = '#1ed760';
      span.style.fontWeight = '700';
    } else {
      span.style.color = '';
      span.style.fontWeight = '';
    }
  });
}

// Play a selected audio file
function playFile(file, folderNode) {
  // Compose stream URL for Google Drive
  const streamUrl = `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media&key=${API_KEY}`;
  audio.src = streamUrl;
  audio.play();
  isPlaying = true;

  // Add to queue if not in
  const foundIndex = queue.findIndex(q => q.id === file.id);
  if (foundIndex === -1) {
    queue.push(file);
    currentIndex = queue.length - 1;
  } else {
    currentIndex = foundIndex;
  }

  renderQueue();
  updatePlayerUI(file, folderNode);
  updatePlayPauseButton();
  highlightQueuePlaying();
}

// Update player UI with metadata and artwork
function updatePlayerUI(file, folderNode) {
  const meta = metadataMap[file.name] || {};
  const artwork = meta.artwork || `https://raw.githubusercontent.com/bobobo1343/DISCOMUSICHUB/main/artworks/${encodeURIComponent(file.name.replace(/\.[^/.]+$/, ''))}.jpg` || 'https://via.placeholder.com/96?text=No+Artwork';

  artworkImg.src = artwork;
  songTitle.textContent = meta.title || file.name;
  songArtist.textContent = meta.artist || (folderNode ? folderNode.name : '');
}

// Render playlist queue UI
function renderQueue() {
  queueList.innerHTML = '';
  queue.forEach((file, idx) => {
    const li = document.createElement('li');
    li.textContent = file.name;
    if (idx === currentIndex) li.classList.add('playing');

    const removeBtn = document.createElement('span');
    removeBtn.textContent = '‚úñ';
    removeBtn.classList.add('remove-btn');
    removeBtn.onclick = e => {
      e.stopPropagation();
      if (idx === currentIndex) {
        audio.pause();
        isPlaying = false;
        updatePlayPauseButton();
        currentIndex = -1;
      }
      queue.splice(idx, 1);
      if (idx < currentIndex) currentIndex--;
      renderQueue();
    };

    li.appendChild(removeBtn);

    li.onclick = () => {
      currentIndex = idx;
      playFile(file);
    };

    queueList.appendChild(li);
  });
}

// Highlight playing queue item
function highlightQueuePlaying() {
  const items = queueList.querySelectorAll('li');
  items.forEach(item => item.classList.remove('playing'));
  if (currentIndex >= 0 && items[currentIndex]) {
    items[currentIndex].classList.add('playing');
    items[currentIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// Play controls
playPauseBtn.onclick = () => {
  if (!audio.src) return;
  if (audio.paused) {
    audio.play();
    isPlaying = true;
  } else {
    audio.pause();
    isPlaying = false;
  }
  updatePlayPauseButton();
};

prevBtn.onclick = () => {
  if (queue.length === 0) return;
  if (shuffleMode) {
    currentIndex = Math.floor(Math.random() * queue.length);
  } else {
    currentIndex = (currentIndex - 1 + queue.length) % queue.length;
  }
  playFile(queue[currentIndex]);
};

nextBtn.onclick = () => {
  if (queue.length === 0) return;
  if (shuffleMode) {
    currentIndex = Math.floor(Math.random() * queue.length);
  } else {
    currentIndex++;
    if (currentIndex >= queue.length) {
      if (repeatMode === 2) currentIndex = 0;
      else {
        currentIndex = queue.length - 1;
        audio.pause();
        isPlaying = false;
        updatePlayPauseButton();
        return;
      }
    }
  }
  playFile(queue[currentIndex]);
};

// Audio events
audio.onended = () => {
  if (repeatMode === 1) {
    audio.currentTime = 0;
    audio.play();
  } else {
    nextBtn.onclick();
  }
};

audio.ontimeupdate = () => {
  if (audio.duration) {
    const percent = (audio.currentTime / audio.duration) * 100;
    progress.style.width = percent + '%';
    timeInfo.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
  }
};

// Seek bar interaction
progressContainer.onclick = e => {
  const rect = progressContainer.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const pct = clickX / rect.width;
  if (audio.duration) audio.currentTime = pct * audio.duration;
};

// Volume
volumeSlider.value = 1;
audio.volume = 1;

volumeSlider.oninput = () => {
  audio.volume = volumeSlider.value;
  muteToggle.textContent = audio.volume > 0 ? 'üîä' : 'üîà';
};

muteToggle.onclick = () => {
  if (audio.volume > 0) {
    audio.volume = 0;
    volumeSlider.value = 0;
    muteToggle.textContent = 'üîà';
  } else {
    audio.volume = 1;
    volumeSlider.value = 1;
    muteToggle.textContent = 'üîä';
  }
};

// Repeat & shuffle buttons
repeatBtn.onclick = () => {
  repeatMode = (repeatMode + 1) % 3;
  updateRepeatShuffleUI();
};

shuffleBtn.onclick = () => {
  shuffleMode = !shuffleMode;
  updateRepeatShuffleUI();
};

function updateRepeatShuffleUI() {
  repeatBtn.classList.toggle('active', repeatMode !== 0);
  if (repeatMode === 0) repeatBtn.textContent = 'üîÅ'; // off
  else if (repeatMode === 1) repeatBtn.textContent = 'üîÇ'; // one
  else if (repeatMode === 2) repeatBtn.textContent = 'üîÅ'; // all

  shuffleBtn.classList.toggle('active', shuffleMode);
}

// Search filter
searchInput.oninput = () => {
  const val = searchInput.value.toLowerCase();
  [...folderTree.querySelectorAll('li')].forEach(li => {
    const txt = li.textContent.toLowerCase();
    li.style.display = txt.includes(val) ? '' : 'none';
  });
};

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return; // ignore if typing
  switch(e.code){
    case 'Space': e.preventDefault(); playPauseBtn.onclick(); break;
    case 'ArrowRight': nextBtn.onclick(); break;
    case 'ArrowLeft': prevBtn.onclick(); break;
  }
});

// Theme toggle
let darkTheme = true;
themeToggleBtn.onclick = () => {
  darkTheme = !darkTheme;
  if(darkTheme){
    document.body.style.background = '#121212';
    document.body.style.color = '#eee';
    themeToggleBtn.textContent = 'Light Mode';
  } else {
    document.body.style.background = '#eee';
    document.body.style.color = '#121212';
    themeToggleBtn.textContent = 'Dark Mode';
  }
};

// Helper time format
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Initialize app
async function init() {
  await loadMetadata();

  rootNode = new TreeNode('root', 'Artists', true);
  // Build artist folder nodes
  for (const [artist, folderId] of Object.entries(ARTISTS)) {
    const artistNode = await buildTree(folderId, artist, rootNode);
    rootNode.children.push(artistNode);
  }

  renderFolderTree(rootNode, folderTree);

  // Auto expand artist folders initially
  [...folderTree.querySelectorAll('li.folder > .folder-name')].forEach(el => el.click());
}

init();

</script>
</body>
</html>
